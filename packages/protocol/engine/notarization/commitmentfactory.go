package notarization

import (
	"sync"

	"github.com/cockroachdb/errors"
	"github.com/iotaledger/hive.go/core/identity"
	"github.com/iotaledger/hive.go/core/types"

	"github.com/iotaledger/hive.go/core/generics/lo"

	"github.com/iotaledger/goshimmer/packages/core/ads"
	"github.com/iotaledger/goshimmer/packages/core/chainstorage"
	"github.com/iotaledger/goshimmer/packages/core/commitment"
	"github.com/iotaledger/goshimmer/packages/core/epoch"
	"github.com/iotaledger/goshimmer/packages/core/storable"
	"github.com/iotaledger/goshimmer/packages/protocol/engine/consensus/acceptance"
	"github.com/iotaledger/goshimmer/packages/protocol/engine/tangle/blockdag"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger/utxo"
)

// region CommitmentFactory ///////////////////////////////////////////////////////////////////////////////////////

// commitmentFactory manages epoch commitmentTrees.
type commitmentFactory struct {
	stateTree *ads.Set[utxo.OutputID]
	manaTree  *ads.Map[identity.ID, storable.SerializableUint64, *storable.SerializableUint64]

	mutationFactory *mutationFactory

	// latestCommitment holds the latest commitment generated by the factory, to be used to compute PrevID for subsequent commitments.
	latestCommitment *commitment.Commitment

	sync.RWMutex
}

func newCommitmentFactory(genesisCommitment *commitment.Commitment, chainStorage *chainstorage.ChainStorage) *commitmentFactory {
	return &commitmentFactory{
		latestCommitment: genesisCommitment,
		mutationFactory:  newMutationFactory(genesisCommitment.Index()),
		stateTree:        ads.NewSet[utxo.OutputID](chainStorage.StateTreeStorage()),
		manaTree:         ads.NewMap[identity.ID, storable.SerializableUint64, *storable.SerializableUint64](chainStorage.ManaTreeStorage()),
	}
}

// LatestCommitment returns the latest commitment that a new block should commit to.
func (f *commitmentFactory) LatestCommitment() (commitment *commitment.Commitment) {
	f.RLock()
	defer f.RUnlock()

	return f.latestCommitment
}

// OnBlockAccepted is the handler for block confirmed event.
func (f *commitmentFactory) AddAcceptedBlock(block *acceptance.Block) (err error) {
	f.Lock()
	defer f.Unlock()

	if ei := epoch.IndexFromTime(block.IssuingTime()); ei <= f.latestCommitment.Index() {
		return errors.Errorf("block %s accepted with issuing time %s in already committed epoch %d", block.ID(), block.IssuingTime(), ei)
	}

	f.mutationFactory.addAcceptedBlock(block.IssuerID(), block.ID())

	return
}

// OnBlockOrphaned is the handler for block orphaned event.
func (f *commitmentFactory) RemoveAcceptedBlock(block *blockdag.Block) (err error) {
	f.Lock()
	defer f.Unlock()

	if ei := epoch.IndexFromTime(block.IssuingTime()); ei <= f.latestCommitment.Index() {
		return errors.Errorf("block %s orphaned with issuing time %s in already committed epoch %d", block.ID(), block.IssuingTime(), ei)
	}

	f.mutationFactory.removeAcceptedBlock(block.IssuerID(), block.ID())

	return
}

// OnTransactionAccepted is the handler for transaction accepted event.
func (f *commitmentFactory) AddAcceptedTransaction(txMeta *ledger.TransactionMetadata) (err error) {
	f.Lock()
	defer f.Unlock()

	txEpoch := epoch.IndexFromTime(txMeta.InclusionTime())
	if txEpoch <= f.latestCommitment.Index() {
		return errors.Errorf("transaction %s accepted with issuing time %s in already committed epoch %d", txMeta.ID(), txMeta.InclusionTime(), txEpoch)
	}

	f.mutationFactory.addAcceptedTransaction(txEpoch, txMeta.ID())

	return
}

// OnTransactionInclusionUpdated is the handler for transaction inclusion updated event.
func (f *commitmentFactory) UpdateAcceptedTransaction(event *ledger.TransactionInclusionUpdatedEvent) {
	f.epochCommitmentFactoryMutex.Lock()
	defer f.epochCommitmentFactoryMutex.Unlock()

	oldEpoch := epoch.IndexFromTime(event.PreviousInclusionTime)
	newEpoch := epoch.IndexFromTime(event.InclusionTime)

	if oldEpoch == 0 || oldEpoch == newEpoch {
		return
	}

	if f.isEpochAlreadyCommitted(oldEpoch) || f.isEpochAlreadyCommitted(newEpoch) {
		f.Events.Error.Trigger(errors.Errorf("inclusion time of transaction changed for already committed epoch: previous Index %d, new Index %d", oldEpoch, newEpoch))
		return
	}

	txID := event.TransactionID

	has, err := f.isTransactionInEpoch(event.TransactionID, oldEpoch)
	if err != nil {
		f.Events.Error.Trigger(err)
		return
	}
	if !has {
		return
	}

	var spent, created []*ledger.OutputWithMetadata
	f.ledger.Storage.CachedTransaction(txID).Consume(func(tx utxo.Transaction) {
		spent, created = f.resolveOutputs(tx)
	})

	if err := f.removeTransactionFromEpoch(txID, oldEpoch, spent, created); err != nil {
		f.Events.Error.Trigger(err)
	}

	if err := f.includeTransactionInEpoch(txID, newEpoch, spent, created); err != nil {
		f.Events.Error.Trigger(err)
	}
}

/*
TODO: We need OnTransactionOrphaned event
*/
func (f *commitmentFactory) RemoveAcceptedTransaction(tx utxo.Transaction) {
	/*
		spent, created := f.resolveOutputs(tx)
		f.commitmentFactory.deleteDiffUTXOs(ei, created, spent)
		f.Events.UTXOTreeRemoved.Trigger(&UTXOUpdatedEvent{EI: ei, Spent: spent, Created: created})
	*/
}

func (f *commitmentFactory) createCommitment(ei epoch.Index, spentOutputs, createdOutputs []*ledger.OutputWithMetadata) (newCommitment *commitment.Commitment, err error) {
	if ei != f.latestCommitment.Index()+1 {
		return nil, errors.Errorf("cannot create commitment for epoch %d, latest commitment is for epoch %d", ei, f.latestCommitment.Index())
	}

	tangleRoot, stateMutationRoot, activityRoot := f.mutationFactory.commit(ei)
	stateRoot, manaRoot := f.advanceStateRoots(spentOutputs, createdOutputs)

	// TODO: obtain and commit to cumulative weight
	newCommitment = commitment.New(ei, f.latestCommitment.ID(), commitment.NewRoots(tangleRoot, stateMutationRoot, activityRoot, stateRoot, manaRoot).ID(), 0)

	f.latestCommitment = newCommitment

	return
}

func (f *commitmentFactory) advanceStateRoots(spentOutputs, createdOutputs []*ledger.OutputWithMetadata) (stateRoot, manaRoot types.Identifier) {
	// Insert  created UTXOs into the state tree.
	for _, created := range createdOutputs {
		f.stateTree.Add(created.ID())

		if iotaBalance, exists := created.IOTABalance(); exists {
			pledgeID := created.ConsensusManaPledgeID()
			f.manaTree.Set(pledgeID, lo.Return1(f.manaTree.Get(pledgeID))+storable.SerializableUint64(iotaBalance))
		}
	}

	// Remove spent UTXOs from the state tree.
	for _, spent := range spentOutputs {
		f.stateTree.Delete(spent.ID())

		iotaBalance, exists := spent.IOTABalance()
		if !exists {
			continue
		}

		spentPledge := spent.ConsensusManaPledgeID()
		weight := lo.Return1(f.manaTree.Get(spentPledge)) - storable.SerializableUint64(iotaBalance)
		if weight <= 0 {
			f.manaTree.Delete(spentPledge)
			continue
		}

		f.manaTree.Set(spentPledge, weight)
	}

	return f.stateTree.Root(), f.manaTree.Root()
}

/*
// storeDiffUTXOs stores the diff UTXOs occurred on an epoch without removing UTXOs created and spent in the span of a
// single epoch. This is because, as UTXOs can be stored out-of-order, we cannot reliably remove intermediate UTXOs
// before an epoch is committable.
func (f *CommitmentFactory) storeDiffUTXOs(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) {
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	for _, spentOutputWithMetadata := range spent {
		cachedObj, stored := epochDiffStorage.spent.StoreIfAbsent(spentOutputWithMetadata)
		if !stored {
			continue
		}
		cachedObj.Release()
	}

	for _, createdOutputWithMetadata := range created {
		cachedObj, stored := epochDiffStorage.created.StoreIfAbsent(createdOutputWithMetadata)
		if !stored {
			continue
		}
		cachedObj.Release()
	}
}

func (f *CommitmentFactory) deleteDiffUTXOs(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) {
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	for _, spentOutputWithMetadata := range spent {
		epochDiffStorage.spent.Delete(spentOutputWithMetadata.ID().Bytes())
	}

	for _, createdOutputWithMetadata := range created {
		epochDiffStorage.created.Delete(createdOutputWithMetadata.ID().Bytes())
	}
}

// loadDiffUTXOs loads the diff UTXOs occurred on an epoch by removing UTXOs created and spent in the span of the same epoch,
// as by the time we load a diff we assume the epoch is being committed and cannot be altered anymore.
func (f *CommitmentFactory) loadDiffUTXOs(ei epoch.Index) (spent, created []*ledger.OutputWithMetadata) {
	f.chainStorage
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	spent = make([]*ledger.OutputWithMetadata, 0)
	epochDiffStorage.spent.ForEach(func(_ []byte, cachedOutputWithMetadata *objectstorage.CachedObject[*ledger.OutputWithMetadata]) bool {
		cachedOutputWithMetadata.Consume(func(outputWithMetadata *ledger.OutputWithMetadata) {
			// We remove spent and created UTXOs happened in the same epoch, as we assume that by the time we
			// load the epoch diff, the epoch is being committed and cannot be altered anymore.
			if epochDiffStorage.created.DeleteIfPresent(outputWithMetadata.ID().Bytes()) {
				epochDiffStorage.spent.Delete(outputWithMetadata.ID().Bytes())
				return
			}
			spent = append(spent, outputWithMetadata)
		})
		return true
	})

	created = make([]*ledger.OutputWithMetadata, 0)
	epochDiffStorage.created.ForEach(func(_ []byte, cachedOutputWithMetadata *objectstorage.CachedObject[*ledger.OutputWithMetadata]) bool {
		cachedOutputWithMetadata.Consume(func(outputWithMetadata *ledger.OutputWithMetadata) {
			created = append(created, outputWithMetadata)
		})
		return true
	})

	return
}
*/

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////
