package notarization

import (
	"sync"

	"github.com/cockroachdb/errors"
	"github.com/iotaledger/hive.go/core/identity"
	"github.com/iotaledger/hive.go/core/types"

	"github.com/iotaledger/hive.go/core/generics/lo"

	"github.com/iotaledger/goshimmer/packages/core/ads"
	"github.com/iotaledger/goshimmer/packages/core/chainstorage"
	"github.com/iotaledger/goshimmer/packages/core/commitment"
	"github.com/iotaledger/goshimmer/packages/core/epoch"
	"github.com/iotaledger/goshimmer/packages/core/storable"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger/utxo"
)

// region CommitmentFactory ///////////////////////////////////////////////////////////////////////////////////////

// commitmentFactory manages epoch commitmentTrees.
type commitmentFactory struct {
	Events *Events

	stateTree *ads.Set[utxo.OutputID]
	manaTree  *ads.Map[identity.ID, storable.SerializableInt64, *storable.SerializableInt64]

	*MutationFactory

	// latestCommitment holds the latest commitment generated by the factory, to be used to compute PrevID for subsequent commitments.
	latestCommitment *commitment.Commitment

	sync.RWMutex
}

func newCommitmentFactory(genesisCommitment *commitment.Commitment, chainStorage *chainstorage.ChainStorage) *commitmentFactory {
	return &commitmentFactory{
		Events:           NewEvents(),
		latestCommitment: genesisCommitment,
		MutationFactory:  NewMutationFactory(genesisCommitment.Index()),
		stateTree:        ads.NewSet[utxo.OutputID](chainStorage.StateTreeStorage()),
		manaTree:         ads.NewMap[identity.ID, storable.SerializableInt64](chainStorage.ManaTreeStorage()),
	}
}

// LatestCommitment returns the latest commitment that a new block should commit to.
func (f *commitmentFactory) LatestCommitment() (commitment *commitment.Commitment) {
	f.RLock()
	defer f.RUnlock()

	return f.latestCommitment
}

// OnTransactionAccepted is the handler for transaction accepted event.
func (f *commitmentFactory) AddAcceptedTransaction(txMeta *ledger.TransactionMetadata) (err error) {
	f.Lock()
	defer f.Unlock()

	txEpoch := epoch.IndexFromTime(txMeta.InclusionTime())
	if txEpoch <= f.latestCommitment.Index() {
		return errors.Errorf("transaction %s accepted with issuing time %s in already committed epoch %d", txMeta.ID(), txMeta.InclusionTime(), txEpoch)
	}

	f.MutationFactory.AddAcceptedTransaction(txEpoch, txMeta.ID())

	return
}

// OnTransactionInclusionUpdated is the handler for transaction inclusion updated event.
func (f *commitmentFactory) UpdateTransactionInclusionTime(event *ledger.TransactionInclusionUpdatedEvent) (err error) {
	f.Lock()
	defer f.Unlock()

	oldEpoch := epoch.IndexFromTime(event.PreviousInclusionTime)
	newEpoch := epoch.IndexFromTime(event.InclusionTime)

	if oldEpoch == 0 || oldEpoch == newEpoch {
		return
	}

	if oldEpoch <= f.latestCommitment.Index() || newEpoch <= f.latestCommitment.Index() {
		return errors.Errorf("inclusion time of transaction changed for already committed epoch: previous Index %d, new Index %d", oldEpoch, newEpoch)
	}

	f.MutationFactory.RemoveAcceptedTransaction(oldEpoch, event.TransactionID)
	f.MutationFactory.AddAcceptedTransaction(newEpoch, event.TransactionID)

	return
}

// TODO: We need OnTransactionOrphaned event
func (f *commitmentFactory) RemoveAcceptedTransaction(tx utxo.Transaction) {
	/*
		spent, created := f.resolveOutputs(tx)
		f.commitmentFactory.deleteDiffUTXOs(ei, created, spent)
		f.Events.UTXOTreeRemoved.Trigger(&UTXOUpdatedEvent{EI: ei, Spent: spent, Created: created})
	*/
}

func (f *commitmentFactory) createCommitment(ei epoch.Index, spentOutputs, createdOutputs []*chainstorage.OutputWithMetadata) (newCommitment *commitment.Commitment, err error) {
	if ei != f.latestCommitment.Index()+1 {
		return nil, errors.Errorf("cannot create commitment for epoch %d, latest commitment is for epoch %d", ei, f.latestCommitment.Index())
	}

	acceptedBlocks, acceptedTransactions, activeValidators := f.MutationFactory.Commit(ei)
	stateRoot, manaRoot := f.advanceStateRoots(ei, spentOutputs, createdOutputs)

	// TODO: obtain and commit to cumulative weight
	newCommitment = commitment.New(ei, f.latestCommitment.ID(), commitment.NewRoots(acceptedBlocks.Root(), acceptedTransactions.Root(), activeValidators.Root(), stateRoot, manaRoot).ID(), 0)

	f.latestCommitment = newCommitment

	return
}

func (f *commitmentFactory) advanceStateRoots(ei epoch.Index, spentOutputs, createdOutputs []*chainstorage.OutputWithMetadata) (stateRoot, manaRoot types.Identifier) {
	manaUpdates := make(map[identity.ID]*ConsensusWeightUpdate)

	// Insert  created UTXOs into the state tree.
	for _, created := range createdOutputs {
		f.stateTree.Add(created.ID())

		iotaBalance, exists := created.IOTABalance()
		if !exists {
			continue
		}

		pledgeID := created.ConsensusManaPledgeID()
		manaUpdate, exists := manaUpdates[pledgeID]
		if !exists {
			manaUpdate = newConsesusWeightUpdate(int64(lo.Return1(f.manaTree.Get(pledgeID))))
			manaUpdates[pledgeID] = manaUpdate
		}

		manaUpdate.Diff += int64(iotaBalance)
	}

	// Remove spent UTXOs from the state tree.
	for _, spent := range spentOutputs {
		f.stateTree.Delete(spent.ID())

		iotaBalance, exists := spent.IOTABalance()
		if !exists {
			continue
		}

		pledgeID := spent.ConsensusManaPledgeID()
		manaUpdate, exists := manaUpdates[pledgeID]
		if !exists {
			manaUpdate = newConsesusWeightUpdate(int64(lo.Return1(f.manaTree.Get(pledgeID))))
			manaUpdates[pledgeID] = manaUpdate
		}

		manaUpdate.Diff -= int64(iotaBalance)
	}

	for id, manaUpdate := range manaUpdates {
		newAmount := manaUpdate.OldAmount + manaUpdate.Diff
		if newAmount <= 0 {
			f.manaTree.Delete(id)
			continue
		}

		f.manaTree.Set(id, storable.SerializableInt64(newAmount))
	}

	f.Events.ConsensusWeightsUpdated.Trigger(&ConsensusWeightsUpdatedEvent{
		EI:                      ei,
		AmountAndDiffByIdentity: manaUpdates,
	})

	return f.stateTree.Root(), f.manaTree.Root()
}

/*
// storeDiffUTXOs stores the diff UTXOs occurred on an epoch without removing UTXOs created and spent in the span of a
// single epoch. This is because, as UTXOs can be stored out-of-order, we cannot reliably remove intermediate UTXOs
// before an epoch is committable.
func (f *CommitmentFactory) storeDiffUTXOs(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) {
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	for _, spentOutputWithMetadata := range spent {
		cachedObj, stored := epochDiffStorage.spent.StoreIfAbsent(spentOutputWithMetadata)
		if !stored {
			continue
		}
		cachedObj.Release()
	}

	for _, createdOutputWithMetadata := range created {
		cachedObj, stored := epochDiffStorage.created.StoreIfAbsent(createdOutputWithMetadata)
		if !stored {
			continue
		}
		cachedObj.Release()
	}
}

func (f *CommitmentFactory) deleteDiffUTXOs(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) {
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	for _, spentOutputWithMetadata := range spent {
		epochDiffStorage.spent.Delete(spentOutputWithMetadata.ID().Bytes())
	}

	for _, createdOutputWithMetadata := range created {
		epochDiffStorage.created.Delete(createdOutputWithMetadata.ID().Bytes())
	}
}

// loadDiffUTXOs loads the diff UTXOs occurred on an epoch by removing UTXOs created and spent in the span of the same epoch,
// as by the time we load a diff we assume the epoch is being committed and cannot be altered anymore.
func (f *CommitmentFactory) loadDiffUTXOs(ei epoch.Index) (spent, created []*ledger.OutputWithMetadata) {
	f.chainStorage
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	spent = make([]*ledger.OutputWithMetadata, 0)
	epochDiffStorage.spent.ForEach(func(_ []byte, cachedOutputWithMetadata *objectstorage.CachedObject[*ledger.OutputWithMetadata]) bool {
		cachedOutputWithMetadata.Consume(func(outputWithMetadata *ledger.OutputWithMetadata) {
			// We remove spent and created UTXOs happened in the same epoch, as we assume that by the time we
			// load the epoch diff, the epoch is being committed and cannot be altered anymore.
			if epochDiffStorage.created.DeleteIfPresent(outputWithMetadata.ID().Bytes()) {
				epochDiffStorage.spent.Delete(outputWithMetadata.ID().Bytes())
				return
			}
			spent = append(spent, outputWithMetadata)
		})
		return true
	})

	created = make([]*ledger.OutputWithMetadata, 0)
	epochDiffStorage.created.ForEach(func(_ []byte, cachedOutputWithMetadata *objectstorage.CachedObject[*ledger.OutputWithMetadata]) bool {
		cachedOutputWithMetadata.Consume(func(outputWithMetadata *ledger.OutputWithMetadata) {
			created = append(created, outputWithMetadata)
		})
		return true
	})

	return
}
*/

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////
