package notarization

import (
	"sync"

	"github.com/cockroachdb/errors"
	"github.com/iotaledger/hive.go/core/identity"
	"github.com/iotaledger/hive.go/core/types"

	"github.com/iotaledger/hive.go/core/generics/lo"

	"github.com/iotaledger/goshimmer/packages/core/ads"
	"github.com/iotaledger/goshimmer/packages/core/chainstorage"
	"github.com/iotaledger/goshimmer/packages/core/commitment"
	"github.com/iotaledger/goshimmer/packages/core/epoch"
	"github.com/iotaledger/goshimmer/packages/core/storable"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger/utxo"
)

// region CommitmentFactory ///////////////////////////////////////////////////////////////////////////////////////

// commitmentFactory manages epoch commitmentTrees.
type commitmentFactory struct {
	Events *Events

	stateTree *ads.Set[utxo.OutputID]
	manaTree  *ads.Map[identity.ID, storable.SerializableInt64, *storable.SerializableInt64]

	*MutationFactory

	// latestCommitment holds the latest commitment generated by the factory, to be used to compute PrevID for subsequent commitments.
	latestCommitment *commitment.Commitment

	sync.RWMutex
}

func newCommitmentFactory(genesisCommitment *commitment.Commitment, chainStorage *chainstorage.ChainStorage) *commitmentFactory {
	return &commitmentFactory{
		Events:           NewEvents(),
		latestCommitment: genesisCommitment,
		MutationFactory:  NewMutationFactory(genesisCommitment.Index()),
		stateTree:        ads.NewSet[utxo.OutputID](chainStorage.StateTreeStorage()),
		manaTree:         ads.NewMap[identity.ID, storable.SerializableInt64](chainStorage.ManaTreeStorage()),
	}
}

// LatestCommitment returns the latest commitment that a new block should commit to.
func (f *commitmentFactory) LatestCommitment() (commitment *commitment.Commitment) {
	f.RLock()
	defer f.RUnlock()

	return f.latestCommitment
}

func (f *commitmentFactory) createCommitment(ei epoch.Index, spentOutputs, createdOutputs []*chainstorage.OutputWithMetadata) (newCommitment *commitment.Commitment, err error) {
	if ei != f.latestCommitment.Index()+1 {
		return nil, errors.Errorf("cannot create commitment for epoch %d, latest commitment is for epoch %d", ei, f.latestCommitment.Index())
	}

	acceptedBlocks, acceptedTransactions, activeValidators, err := f.MutationFactory.Commit(ei)
	if err != nil {
		return nil, errors.Errorf("failed to commit mutations: %w", err)
	}
	stateRoot, manaRoot := f.advanceStateRoots(ei, spentOutputs, createdOutputs)

	// TODO: obtain and commit to cumulative weight
	newCommitment = commitment.New(ei, f.latestCommitment.ID(), commitment.NewRoots(acceptedBlocks.Root(), acceptedTransactions.Root(), activeValidators.Root(), stateRoot, manaRoot).ID(), 0)

	f.latestCommitment = newCommitment

	return
}

func (f *commitmentFactory) advanceStateRoots(ei epoch.Index, spentOutputs, createdOutputs []*chainstorage.OutputWithMetadata) (stateRoot, manaRoot types.Identifier) {
	manaUpdates := make(map[identity.ID]*ConsensusWeightUpdate)

	// Insert  created UTXOs into the state tree.
	for _, created := range createdOutputs {
		f.stateTree.Add(created.ID())

		iotaBalance, exists := created.IOTABalance()
		if !exists {
			continue
		}

		pledgeID := created.ConsensusManaPledgeID()
		manaUpdate, exists := manaUpdates[pledgeID]
		if !exists {
			manaUpdate = newConsesusWeightUpdate(int64(lo.Return1(f.manaTree.Get(pledgeID))))
			manaUpdates[pledgeID] = manaUpdate
		}

		manaUpdate.Diff += int64(iotaBalance)
	}

	// Remove spent UTXOs from the state tree.
	for _, spent := range spentOutputs {
		f.stateTree.Delete(spent.ID())

		iotaBalance, exists := spent.IOTABalance()
		if !exists {
			continue
		}

		pledgeID := spent.ConsensusManaPledgeID()
		manaUpdate, exists := manaUpdates[pledgeID]
		if !exists {
			manaUpdate = newConsesusWeightUpdate(int64(lo.Return1(f.manaTree.Get(pledgeID))))
			manaUpdates[pledgeID] = manaUpdate
		}

		manaUpdate.Diff -= int64(iotaBalance)
	}

	for id, manaUpdate := range manaUpdates {
		newAmount := manaUpdate.OldAmount + manaUpdate.Diff
		if newAmount <= 0 {
			f.manaTree.Delete(id)
			continue
		}

		f.manaTree.Set(id, storable.SerializableInt64(newAmount))
	}

	f.Events.ConsensusWeightsUpdated.Trigger(&ConsensusWeightsUpdatedEvent{
		EI:                      ei,
		AmountAndDiffByIdentity: manaUpdates,
	})

	return f.stateTree.Root(), f.manaTree.Root()
}

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////
