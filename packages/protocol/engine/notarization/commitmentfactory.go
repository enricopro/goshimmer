package notarization

import (
	"github.com/cockroachdb/errors"
	"github.com/iotaledger/hive.go/core/identity"
	"github.com/iotaledger/hive.go/core/types"

	"github.com/iotaledger/hive.go/core/generics/lo"
	"github.com/iotaledger/hive.go/core/generics/objectstorage"

	"github.com/iotaledger/goshimmer/packages/core/ads"
	"github.com/iotaledger/goshimmer/packages/core/chainstorage"
	"github.com/iotaledger/goshimmer/packages/core/commitment"
	"github.com/iotaledger/goshimmer/packages/core/epoch"
	"github.com/iotaledger/goshimmer/packages/core/storable"
	"github.com/iotaledger/goshimmer/packages/protocol/chainmanager"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger/utxo"
)

// region CommitmentFactory ///////////////////////////////////////////////////////////////////////////////////////

// CommitmentFactory manages epoch commitmentTrees.
type CommitmentFactory struct {
	storage *EpochCommitmentStorage

	unspentOutputsSet *ads.Set[utxo.OutputID]
	consensusWeights  *ads.Map[identity.ID, storable.SerializableUint64, *storable.SerializableUint64]

	mutationFactory *mutationFactory

	// latestCommitment holds the latest commitment generated by the factory, to be used to compute PrevID for subsequent commitments.
	latestCommitment *commitment.Commitment
}

// NewCommitmentFactory returns a new commitment factory.
func NewCommitmentFactory(genesisCommitment *commitment.Commitment, chainStorage *chainstorage.ChainStorage, snapshotDepth int) *CommitmentFactory {
	return &CommitmentFactory{
		latestCommitment:  genesisCommitment,
		mutationFactory:   newMutationFactory(genesisCommitment.Index()),
		unspentOutputsSet: ads.NewSet[utxo.OutputID](chainStorage.StateTreeStorage()),
		consensusWeights:  ads.NewMap[identity.ID, storable.SerializableUint64, *storable.SerializableUint64](chainStorage.ManaTreeStorage()),
	}
}

// ecRecord retrieves the epoch commitment.
func (f *CommitmentFactory) createCommitment(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) (newCommitment *commitment.Commitment, err error) {
	if ei != f.latestCommitment.Index()+1 {
		return nil, errors.Errorf("cannot create commitment for epoch %d, latest commitment is for epoch %d", ei, f.latestCommitment.Index())
	}

	tangleRoot, stateMutationRoot, activityRoot := f.mutationFactory.commit(ei)
	stateRoot, manaRoot := f.newStateRoots(ei, spent, created)

	commitmentTrees, commitmentTreesErr := f.getCommitmentTrees(ei)
	if commitmentTreesErr != nil {
		return nil, errors.Wrapf(commitmentTreesErr, "cannot get commitment tree for epoch %d", ei)
	}
	roots, ecrErr := f.ECRandRoots(ei, commitmentTrees)
	if ecrErr != nil {
		return nil, ecrErr
	}
	prevECRecord, ecrRecordErr := f.createCommitment(ei - 1)
	if ecrRecordErr != nil {
		return nil, ecrRecordErr
	}

	newCommitment := commitment.New(ei, prevECRecord.ID(), roots.ID(), 0) // TODO: REPLACE CUMULATIVE WEIGHT

	// Store and return.
	f.storage.CachedECRecord(ei, func(ei epoch.Index) *chainmanager.Commitment {
		return chainmanager.NewCommitment(newCommitment.ID())
	}).Consume(func(e *chainmanager.Commitment) {
		ecRecord = e
		ecRecord.PublishCommitment(newCommitment)
		ecRecord.PublishRoots(roots)
	})

	return ecRecord, nil
}

func (f *CommitmentFactory) loadECRecord(ei epoch.Index) (ecRecord *chainmanager.Commitment) {
	f.storage.CachedECRecord(ei).Consume(func(record *chainmanager.Commitment) {
		ecRecord = record
	})
	return
}

// storeDiffUTXOs stores the diff UTXOs occurred on an epoch without removing UTXOs created and spent in the span of a
// single epoch. This is because, as UTXOs can be stored out-of-order, we cannot reliably remove intermediate UTXOs
// before an epoch is committable.
func (f *CommitmentFactory) storeDiffUTXOs(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) {
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	for _, spentOutputWithMetadata := range spent {
		cachedObj, stored := epochDiffStorage.spent.StoreIfAbsent(spentOutputWithMetadata)
		if !stored {
			continue
		}
		cachedObj.Release()
	}

	for _, createdOutputWithMetadata := range created {
		cachedObj, stored := epochDiffStorage.created.StoreIfAbsent(createdOutputWithMetadata)
		if !stored {
			continue
		}
		cachedObj.Release()
	}
}

func (f *CommitmentFactory) deleteDiffUTXOs(ei epoch.Index, spent, created []*ledger.OutputWithMetadata) {
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	for _, spentOutputWithMetadata := range spent {
		epochDiffStorage.spent.Delete(spentOutputWithMetadata.ID().Bytes())
	}

	for _, createdOutputWithMetadata := range created {
		epochDiffStorage.created.Delete(createdOutputWithMetadata.ID().Bytes())
	}
}

// loadDiffUTXOs loads the diff UTXOs occurred on an epoch by removing UTXOs created and spent in the span of the same epoch,
// as by the time we load a diff we assume the epoch is being committed and cannot be altered anymore.
func (f *CommitmentFactory) loadDiffUTXOs(ei epoch.Index) (spent, created []*ledger.OutputWithMetadata) {
	f.chainStorage
	epochDiffStorage := f.storage.getEpochDiffStorage(ei)

	spent = make([]*ledger.OutputWithMetadata, 0)
	epochDiffStorage.spent.ForEach(func(_ []byte, cachedOutputWithMetadata *objectstorage.CachedObject[*ledger.OutputWithMetadata]) bool {
		cachedOutputWithMetadata.Consume(func(outputWithMetadata *ledger.OutputWithMetadata) {
			// We remove spent and created UTXOs happened in the same epoch, as we assume that by the time we
			// load the epoch diff, the epoch is being committed and cannot be altered anymore.
			if epochDiffStorage.created.DeleteIfPresent(outputWithMetadata.ID().Bytes()) {
				epochDiffStorage.spent.Delete(outputWithMetadata.ID().Bytes())
				return
			}
			spent = append(spent, outputWithMetadata)
		})
		return true
	})

	created = make([]*ledger.OutputWithMetadata, 0)
	epochDiffStorage.created.ForEach(func(_ []byte, cachedOutputWithMetadata *objectstorage.CachedObject[*ledger.OutputWithMetadata]) bool {
		cachedOutputWithMetadata.Consume(func(outputWithMetadata *ledger.OutputWithMetadata) {
			created = append(created, outputWithMetadata)
		})
		return true
	})

	return
}

func (f *CommitmentFactory) advanceStateRoots(spentOutputs, createdOutputs []*ledger.OutputWithMetadata) (stateRoot types.Identifier, manaRoot types.Identifier) {
	// Insert  created UTXOs into the state tree.
	for _, created := range createdOutputs {
		f.unspentOutputsSet.Add(created.ID())

		if iotaBalance, exists := created.IOTABalance(); exists {
			pledgeID := created.ConsensusManaPledgeID()
			f.consensusWeights.Set(pledgeID, lo.Return1(f.consensusWeights.Get(pledgeID))+storable.SerializableUint64(iotaBalance))
		}
	}

	// Remove spent UTXOs from the state tree.
	for _, spent := range spentOutputs {
		f.unspentOutputsSet.Delete(spent.ID())

		iotaBalance, exists := spent.IOTABalance()
		if !exists {
			continue
		}

		spentPledge := spent.ConsensusManaPledgeID()
		weight := lo.Return1(f.consensusWeights.Get(spentPledge)) - storable.SerializableUint64(iotaBalance)
		if weight <= 0 {
			f.consensusWeights.Delete(spentPledge)
			continue
		}

		f.consensusWeights.Set(spentPledge, weight)
	}

	return f.unspentOutputsSet.Root(), f.consensusWeights.Root()
}

// endregion ///////////////////////////////////////////////////////////////////////////////////////////////////////////
