package chainstorage

import (
	"context"

	"github.com/iotaledger/hive.go/core/generics/event"
	"github.com/iotaledger/hive.go/core/generics/lo"
	"github.com/iotaledger/hive.go/core/identity"
	"github.com/iotaledger/hive.go/core/serix"
	"github.com/iotaledger/hive.go/core/types"

	"github.com/iotaledger/goshimmer/packages/core/ads"
	"github.com/iotaledger/goshimmer/packages/core/epoch"
	"github.com/iotaledger/goshimmer/packages/protocol/ledger/utxo"
)

type StateEvents struct {
	ConsensusWeightsUpdated *event.Linkable[*ConsensusWeightsUpdatedEvent]

	event.LinkableCollection[StateEvents, *StateEvents]
}

// NewStateEvents contains the constructor of the Events object (it is generated by a generic factory).
var NewStateEvents = event.LinkableConstructor(func() (self *StateEvents) {
	return &StateEvents{
		ConsensusWeightsUpdated: event.NewLinkable[*ConsensusWeightsUpdatedEvent](),
	}
})

type State struct {
	Events *StateEvents

	chainStorage     *ChainStorage
	unspentOutputIDs *ads.Set[utxo.OutputID]
	consensusWeights *ads.Map[identity.ID, TimedBalance, *TimedBalance]
}

func NewState(chainStorage *ChainStorage) (newState *State) {
	return &State{
		Events:           NewStateEvents(),
		chainStorage:     chainStorage,
		unspentOutputIDs: ads.NewSet[utxo.OutputID](chainStorage.permanentStorage(StateTreeStorageType)),
		consensusWeights: ads.NewMap[identity.ID, TimedBalance](chainStorage.permanentStorage(ManaTreeStorageType)),
	}
}

func (s *State) ApplyEpoch(index epoch.Index) (stateRoot, manaRoot types.Identifier) {
	return s.applyStateDiff(index, s.chainStorage.DiffStorage.StateDiff(index), s.unspentOutputIDs.Add, void(s.unspentOutputIDs.Delete))
}

func (s *State) RollbackEpochStateDiff(index epoch.Index, stateDiff *StateDiff) (stateRoot, manaRoot types.Identifier) {
	return s.applyStateDiff(index, stateDiff, void(s.unspentOutputIDs.Delete), s.unspentOutputIDs.Add)
}

func (s *State) ImportUnspentOutputIDs(outputIDs []utxo.OutputID) {
	for _, outputID := range outputIDs {
		s.unspentOutputIDs.Add(outputID)
	}
}

func (s *State) applyStateDiff(index epoch.Index, stateDiff *StateDiff, create, delete func(id utxo.OutputID)) (stateRoot, manaRoot types.Identifier) {
	for it := stateDiff.CreatedOutputs.Iterator(); it.HasNext(); {
		create(it.Next())
	}
	for it := stateDiff.DeletedOutputs.Iterator(); it.HasNext(); {
		delete(it.Next())
	}

	consensusWeightUpdates := make(map[identity.ID]*TimedBalance)

	for id, diff := range stateDiff.ConsensusWeightUpdates {
		if diff == 0 {
			continue
		}

		timedBalance := lo.Return1(s.consensusWeights.Get(id))
		if index == timedBalance.LastUpdated {
			continue
		}

		timedBalance.Balance += diff * int64(lo.Compare(index, timedBalance.LastUpdated))
		timedBalance.LastUpdated = index

		consensusWeightUpdates[id] = timedBalance

		if timedBalance.Balance == 0 {
			s.consensusWeights.Delete(id)
		} else {
			s.consensusWeights.Set(id, timedBalance)
		}
	}

	s.Events.ConsensusWeightsUpdated.Trigger(&ConsensusWeightsUpdatedEvent{
		EI:                      index,
		AmountAndDiffByIdentity: consensusWeightUpdates,
	})

	return s.unspentOutputIDs.Root(), s.consensusWeights.Root()
}

type ConsensusWeightUpdate struct {
	OldAmount int64
	Diff      int64
}

func newConsensusWeightUpdate(oldAmount int64) *ConsensusWeightUpdate {
	return &ConsensusWeightUpdate{
		OldAmount: oldAmount,
	}
}

// ConsensusWeightsUpdatedEvent is a container that acts as a dictionary for the EpochCommittable event related parameters.
type ConsensusWeightsUpdatedEvent struct {
	// EI is the index of committable epoch.
	EI epoch.Index

	AmountAndDiffByIdentity map[identity.ID]*TimedBalance
}

type TimedBalance struct {
	Balance     int64       `serix:"0"`
	LastUpdated epoch.Index `serix:"1"`
}

func NewTimedBalance(balance int64, lastUpdated epoch.Index) (timedBalance *TimedBalance) {
	return &TimedBalance{
		Balance:     balance,
		LastUpdated: lastUpdated,
	}
}

func (t TimedBalance) Bytes() ([]byte, error) {
	return serix.DefaultAPI.Encode(context.Background(), t)
}

func (t *TimedBalance) FromBytes(bytes []byte) (int, error) {
	return serix.DefaultAPI.Decode(context.Background(), bytes, t)
}

func void[A, B any](f func(A) B) func(A) {
	return func(a A) { f(a) }
}
